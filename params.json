{"name":"Blackbeard","tagline":"an MVC framework for Node.js, designed to be familar.","body":"# Quickstart\r\n- First, create or generate a **package.json** file (```npm init```)\r\n- Then run ```npm install blackbeard --save```\r\n- Next, add ```\"blackbeard\": \"blackbeard\"``` to your **package.json**'s scripts property\r\n- Finally, run ```npm run blackbeard setup```\r\n\r\nIt is **highly recommended** that you allow the setup to generate some boilerplate code for you. This is the best way to understand and see how the API works.\r\n\r\n***\r\n\r\n# What is Blackbeard?\r\nBlackbeard is a heavily opinionated MVC framework. It was designed to be familar and simple, yet fast and powerful. If you're familiar with .NET MVC or Spring framework, then you should be able to pick up Blackbeard's API pretty quickly.\r\n\r\n# Why Blackbeard?\r\nMost other popular frameworks are great (they're popular for a reason), but JavaScript has evolved very quickly, as of late, and the other frameworks' APIs do not match the new language features. Blackbeard's goal is to be a great framework, but to also use modern and future JavaScript syntax in order to maximize readability and RAD capabilities.\r\n\r\n**Features:**\r\n- Models (via sequelize)\r\n- Views (default via Marko)\r\n- Controllers\r\n- Routing\r\n- Sessions and Caching (via Redis)\r\n- Easy API via Annotations/ Class decorators\r\n- Built-in Error re-routing/ messaging\r\n- Simple API for making external requests\r\n- Very easy to make a RESTful JSON api\r\n\r\n***\r\n\r\n## Installation\r\n\r\n**Requirements:**\r\n- Node >= 4.x\r\n- NPM >= 3.x\r\n\r\nMake sure to have a **package.json** file before installing Blackbeard (```npm init```)\r\n\r\nYou can install Blackbeard via NPM: **```npm install blackbeard --save```**\r\n\r\nOnce Blackbeard, and all of its dependencies have been downloaded, you're going to want to open your **package.json** file.\r\n\r\nIn your package file, add a script, like so:\r\n\r\n```\"scripts\": {\r\n  \"blackbeard\": \"blackbeard\"\r\n},```\r\n\r\nThis links the locally installed ```blackbeard``` command to your npm package file for convenience.\r\n\r\n## Setup\r\nOnce you've installed Blackbeard, and have added the \"blackbeard\" command to your package file, you're going to want to run **```npm run blackbeard setup```** in your command shell.\r\n\r\nYou will then be prompted for some configuration options. It will set up your folder structure, and if you choose to generate some boilerplate code (which is highly recommended that you do so), it will write out some example code for you as well.\r\n\r\nThe setup script will also create a **gulpfile.js** for you. When you are ready to build/transpile your code (via babel), just run **``gulp build``**.\r\n\r\nIf you choose to use a database (via Sequelize), then you will need to install the apropriate modules as well. If you're unsure of what modules you'll need, Sequelize will throw an error that will tell you which modules that you're mising. Future versions of Blackbeard will automatically install these for you upon setup.\r\n\r\n## Examples\r\n**The best way to learn would be to run the setup script, and include the boilerplate code**. It will generate examples for you that you can build off of.\r\n\r\n**Example entry point:**\r\n```javascript\r\nimport './controllers/maincontroller'\r\nimport './controllers/advancedcontroller';\r\n\r\nimport './models/user';\r\nimport './models/comment';\r\n\r\nimport Blackbeard from 'blackbeard';\r\nBlackbeard.start();\r\n```\r\nThe entry point will register all of your controllers and models, and then start the server.\r\n\r\nMost of the API is comprised of class annotations/decorators. The best way to describe this is to simply show you, so here's an example of a very simple controller\r\n\r\n### Controllers\r\n```javascript\r\nimport { Controller, Router, View } from 'blackbeard';\r\nconst { MapRoute, GET } = Router;\r\n\r\n@Controller\r\nclass MainController {\r\n\r\n    @MapRoute('/', GET)\r\n    async index () {\r\n        return new View('index'); // the server will find the view at \"views/main/index.marko\"\r\n    }\r\n\r\n}\r\n```\r\n\r\nNow, that's obviously very simple--what about dealing with more complex routing?\r\n\r\n```javascript\r\nimport { Controller, Router, View } from 'blackbeard';\r\nconst { MapRoute, GET } = Router;\r\n\r\n@Controller\r\n@MapRoute('/advanced')\r\nclass AdvancedController {\r\n\r\n    @MapRoute('/foo/{bar}', GET)\r\n    async index (bar) {\r\n        return new View('index', { bar }); // the server will find the view at \"views/advanced/index.marko\"\r\n    }\r\n\r\n}\r\n```\r\n\r\nWhat exactly did we do? Well, now the Controller has a route; that means that all actions within it will now be accessable via ```/advanced/<the action's route>```. This means that you can reach the index method by navigating to ```/advanced/foo/<whatever>```. You can guess that ```{something}``` denotes a variable path, so the ```bar``` argument will be set to whatever that path is that was navigated to.\r\n\r\nWell, that's great, but what about a POST request?\r\n\r\n```javascript\r\n@MapRoute('/foo', POST)\r\nasync foo (request) {\r\n    const data = request.body.toString();\r\n}\r\n```\r\n\r\nEvery action is also passed the request and response objects--you can access posted data via ```request.body```, but it will be a ```Buffer```, so turn it into a string if you need to (like if you posted some JSON).\r\n\r\nHere's a list of all of the things that are supported by default to return from an action:\r\n- ```new DataString(mimeType, string)```\r\n- ```new File(pathOrBuffer)```\r\n- ```new Media(pathOrBuffer)```\r\n- ```new View(path)```\r\n\r\nBlackbeard also handles returning of Error, Buffer, strings and numbers, and will try to JSON Stringify other Objects.\r\n\r\nIf an action throws an error, or if an error happens while trying to respond, Blackbeard will look for ```/error/<code>``` routes, and send those actions instead. If no route exists for that error code, it will just respond with text. If you'd like to show a custom page for an error, simply create a route for that error code in an ```ErrorController```\r\n\r\n### Models\r\nModels are also described using a class annotation, and besides using modern JavaScript syntax, they are [Sequelize Models](http://docs.sequelizejs.com/en/latest/docs/models-definition/), and can be defined in a *very* similar manner.\r\n\r\n```javascript\r\nimport { Model, Schema } from 'blackbeard';\r\nconst { String, Integer, Text } = Schema;\r\n\r\n@Model\r\nexport default class User {\r\n    name = String;\r\n    age = Integer;\r\n    bio = Text;\r\n}\r\n```\r\n\r\nOnce it comes time to use the Model in one of your controllers, the API has not changed from the original [Sequelize Model Usage](http://docs.sequelizejs.com/en/latest/docs/models-usage/).\r\n\r\n**Here's a list of supported Schema types:**\r\n- String\r\n- Binary\r\n- Text\r\n- Integer\r\n- BigInt\r\n- Float\r\n- Real\r\n- Double\r\n- Decimal\r\n- Date\r\n- Boolean\r\n- Enum\r\n- Array\r\n- JSON\r\n- JSONB\r\n- Blob\r\n- UUID\r\n\r\n### Views\r\nThere's not much to document here, but Blackbeard (by default) uses the [Marko](http://markojs.com/) templating engine, and you can learn about it by reading their documentation.\r\n\r\nThere are plans to support configuring which templating engine to use. It will be a part of the setup script.\r\n\r\n## Annotations\r\nAs stated, most of the API is comprised of class annotations/decorators. Here's a list of them and how you can use them:\r\n\r\n### ```@Cache```\r\n- Used to Cache actions and Models (database queries)\r\n- Can only be used if you enabled caching and are running Redis\r\n- Will either use the maxAge in the config, or you may pass one in\r\n```javascript\r\n@Cache(30)\r\n@Model\r\nexport default class User { ... }\r\n```\r\n```javascript\r\n@Cache\r\nasync myAction () { ... }\r\n```\r\n***\r\n### ```@Controller```\r\n- Used to define a Controller on a class\r\n```javascript\r\n@Controller\r\nclass MainController { ... }\r\n```\r\n***\r\n### ```@EnableCORS```\r\n- Used to enable cross-orign-resource-sharing for that action\r\n- Will either use \"*\" for the allowed origin, or you may pass one in\r\n- Can be used on a Controller, or an action\r\n```javascript\r\n@Controller\r\n@EnableCORS\r\nclass MainController { ... }\r\n```\r\n***\r\n### ```@MapRoute```\r\n- Access it on the ```Router``` object\r\n- Takes a path and a request method\r\n- Paths may contain variables (```{variable}```)\r\n- Currently supports GET, POST, and PUT\r\n- No duplicate routes are allowed; Blackbeard will throw an error\r\n```javascript\r\n@MapRoute('/my/path/{here}', GET)\r\nasync myAction (here) { ... }\r\n```\r\n***\r\n### ```@Requirements```\r\n- Can be used to set restrictions on an action\r\n- Any passed in methods **must** return a Promise\r\n- If any of the promises reject, the server responds with a 401\r\n- Can either be a single promise, or an array of promises\r\n```javascript\r\n@MapRoute('/foo', GET)\r\n@Requirements([myPromise, anotherPromise])\r\nasync foo () { ... }\r\n```\r\n## Sessions\r\nSessions are stored in Redis, so if you want to use the built-in session handling, you'll need to be running a redis server.\r\n\r\nActions may either return a ```Session``` object, which will send as JSON, or you may simply use the ```Session``` object in your action, and use its ```save(request, response)``` method. This will create a key, which will be saved in a cookie, and will store the actual session data in Redis. The data that is store in the session is entirely up to you.\r\n\r\n```javascript\r\nasync my Action (request, response) {\r\n    const session = new Session({\r\n        name: 'UserName',\r\n        id: 1,\r\n        role: 'Admin'\r\n    });\r\n    await session.save(request, response);\r\n}\r\n```\r\n\r\nIf you use the built-in Session management, every View will be passed 2 values.\r\n- ```data.authenticated```: This is a boolean flag\r\n- ```data.session```: This is the actual session (contains the data that you passed into the ```Session```.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}